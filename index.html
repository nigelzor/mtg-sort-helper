<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>MTG Sort Helper</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
        }
        a {
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        .set-grid {
            display: grid;
            grid-column-gap: 0.5em;
            grid-row-gap: 0.2em;
            grid-template-columns: 1em auto auto;
            justify-content: center;
        }
        .set-grid .year {
            grid-column: 1 / span 3;
            font-size: smaller;
            font-style: italic;
            justify-self: center;
        }
        .set-grid .set {
            display: contents;
        }
        .set-grid img {
            grid-column: 1;
            max-width: 1em;
            max-height: 1em;
            align-self: center;
            justify-self: center;
        }
        .set-grid a {
            grid-column: 2;
            justify-self: left;
        }
        .set-grid a.child {
            grid-column: 3;
        }
        .card-grid-wrapper {
            text-align: center;
        }
        .card-grid-wrapper > div {
            text-align: initial;
            display: inline-block;
            max-width: 100%;
        }
        #output.focus .card-grid-wrapper > div:hover .card-grid:not(:hover) {
            opacity: 30%;
        }
        .card-grid {
            border-left: 0.5em solid transparent;
            padding-left: 0.5em;
        }
        .card-grid.W {
            border-color: #f8e7b9;
        }
        .card-grid.U {
            border-color: #0e68ab;
        }
        .card-grid.B {
            border-color: #150b00;
        }
        .card-grid.R {
            border-color: rgb(135,6,36);
        }
        .card-grid.G {
            border-color: #00733e;
        }
        .card-grid.artifact {
            border-color: #7f5845;
        }
        .card-grid.land {
            border-color: #91837a;
        }
        .card-grid.multi {
            border-color: rgb(213,175,70);
        }
        .card {
            break-inside: avoid;
            display: flex;
            align-items: center;
        }
        .card + .card {
            margin-top: 0.2em;
        }
        .name {
            flex: 1 1 auto;
            break-inside: avoid;
        }
        .number {
            flex-shrink: 0;
            margin-right: 0.25em;
            min-width: 1.8em;
            font-size: smaller;
            text-align: center;
            color: #ccc;
        }
        .price {
            flex-shrink: 0;
            margin-left: 0.25em;
            font-size: smaller;
            border-radius: 1em;
            padding: 0 0.2em;
        }
        .price.rare {
            background-color: gold;
        }
        .price.common {
            color: white;
            background-color: black;
        }
        .price.uncommon {
            background-color: silver;
        }
        .price.mythic {
            background-color: orchid;
        }
        form label {
            display: inline-flex;
            max-width: 100%;
        }
        form label span + input,
        form label span + select {
            margin-left: 0.5em;
        }
        form label select {
            flex: 0 1 auto;
            min-width: 0;
        }
        #columns {
            width: 3em;
        }
        @media screen and (max-width: 600px) {
            .no-mobile {
                display: none;
            }
            .card-grid-wrapper > div {
                display: initial;
            }
        }
        @media (hover: none) {
            .needs-mouse {
                display: none;
            }
        }
        @media print {
            #filter {
                display: none;
            }
        }
    </style>
</head>
<body>
<form id="filter">
    <label>
        <span>Set:</span>
        <select id="set">
            <option selected value="">(none selected)</option>
        </select>
    </label>
    <label class="no-mobile">
        <span>Columns:</span>
        <input id="columns" type="number" min="1" value="6" />
    </label>
    <label>
        <span>Exclude Rares:</span>
        <input id="rares" type="checkbox" checked />
    </label>
    <label>
        <span>Exclude Bulk:</span>
        <input id="bulk" type="checkbox" />
    </label>
    <label class="needs-mouse">
        <span>Focus:</span>
        <input id="focus" type="checkbox" />
    </label>
</form>
<hr/>
<div id="output"></div>
</body>
<script type="module">

function h(tag, attributes = {}, children) {
    const element = document.createElement(tag);
    for (const attribute in attributes) {
        if (attributes.hasOwnProperty(attribute)) {
            element.setAttribute(attribute, attributes[attribute]);
        }
    }
    children?.forEach((child) => {
        element.appendChild(typeof child === 'string' ? document.createTextNode(child) : child);
    });
    return element
}

function fetchAll(url) {
    return fetch(url).then((resp) => resp.json()).then((json) => {
        if (json.has_more) {
            return fetchAll(json.next_page).then((more) => json.data.concat(more));
        }
        return json.data;
    });
}

function chunkify(cards) {
    function color(card) {
        const colors = card.colors || card.card_faces?.[0].colors;
        if (colors?.length > 1) {
            return 'multi';
        } else if (colors?.length === 1) {
            return colors[0];
        } else if (/Land/.test(card.type_line)) {
            return 'land';
        } else if (/Artifact/.test(card.type_line)) {
            return 'artifact';
        }
        return 'unknown';
    }

    const chunks = [];
    let lc;
    for (const card of cards) {
        const c = color(card);
        if (lc == null || lc !== c) {
            chunks.push({ color: c, cards: [card] });
        } else {
            chunks[chunks.length - 1].cards.push(card);
        }
        lc = c;
    }
    return chunks;
}

document.addEventListener('DOMContentLoaded', function () {
    const hash = () => new URLSearchParams(`?${window.location.hash.substring(1)}`);
    const newHash = (k, v) => {
        const h = hash();
        h.set(k, v);
        return '#' + h.toString();
    };

    const output = document.getElementById('output');
    const setInput = document.getElementById('set');
    const raresInput = document.getElementById('rares');
    const bulkInput = document.getElementById('bulk');
    const columnsInput = document.getElementById('columns');
    const focusInput = document.getElementById('focus');

    let sets = null;
    let cards = [];

    loading();
    fetchAll('https://api.scryfall.com/sets').then((result) => {
        const selectedSet = hash().get('set');
        sets = result.filter((s) => !s.digital).reverse();
        sets.forEach((set) => {
            const option = h('option', { value: set.code }, [set.name]);
            if (set.code === selectedSet) {
                option.selected = true;
            }
            setInput.appendChild(option);
        });
        redraw();
    });

    window.onhashchange = redraw;

    setInput.addEventListener('change', (event) => {
        window.location.hash = newHash('set', event.currentTarget.value);
    });
    raresInput.addEventListener('change', redraw);
    bulkInput.addEventListener('change', redraw);
    columnsInput.addEventListener('change', redraw);

    function handleFocusChange() {
        output.classList[focusInput.checked ? 'add' : 'remove']('focus');
    }
    focusInput.addEventListener('change', handleFocusChange);
    handleFocusChange();

    function clear() {
        while (output.hasChildNodes()) {
            output.removeChild(output.firstChild);
        }
    }

    function loading() {
        clear();
        output.textContent = 'Loading...'
    }

    function compare(a, b) {
        if (a > b) return 1;
        if (b > a) return -1;
        return 0;
    }

    function price(c) {
        if (c.finishes.includes('foil') && !c.finishes.includes('regular')) {
            return c.prices?.usd_foil;
        }
        return c.prices?.usd;
    }

    function drawCards() {
        clear();
        let selected = cards;
        selected.sort((a, b) => -compare(a.booster, b.booster))
        if (raresInput.checked) {
            selected = selected.filter((c) => c.rarity !== "rare" && c.rarity !== "mythic");
        }
        if (bulkInput.checked) {
            selected = selected.filter((c) => price(c) > 1);
        }
        const chunked = chunkify(selected);
        let first = true;
        const wrapper = h('div');
        let columns = columnsInput.value;
        if (window.matchMedia('screen and (max-width: 600px)').matches) {
            columns = 1; // small screens only get one column
        } else {
            // don't show more columns than there are cards
            columns = Math.min(columns, Math.max(...chunked.map((c) => c.cards.length)));
        }
        for (const chunk of chunked) {
            const grid = h('div', { class: `card-grid ${chunk.color}` }, []);
            grid.style.columnCount = `${columns}`;
            for (const c of chunk.cards) {
                const children = [];
                if (c.collector_number) {
                    children.push(h('span', { class: 'number' }, [`${c.collector_number}`]));
                }
                children.push(h('div', { class: 'name' }, [h('a', { class: 'name', href: c.scryfall_uri, target: '_blank' }, [c.name])]));
                if (price(c) > 1) {
                    children.push(h('span', { class: `price ${c.rarity}` }, [`$${price(c)}`]));
                }
                grid.appendChild(h('div', { class: 'card' }, children));
            }
            if (!first) {
                wrapper.appendChild(h('hr'));
            }
            wrapper.appendChild(grid);
            first = false;
        }
        output.appendChild(h('div', { class: 'card-grid-wrapper' }, [wrapper]));
    }

    function drawSets() {
        clear();
        const grid = h('div', { class: 'set-grid' }, []);
        let lasty;
        const children = sets.filter((s) => s.parent_set_code);
        function shortname(parent, child) {
            if (child.startsWith(parent.name)) {
                return child.substring(parent.name.length + 1);
            }
            const names = [];
            if (parent.code === 'ptk') {
                names.push('Portal: Three Kingdoms');
            }
            if (parent.code === 'snc') {
                names.push('New Capenna');
            }
            if (parent.code === 'afr') {
                names.push('Forgotten Realms');
            }
            if (parent.name.includes(': ')) {
                names.push(...parent.name.split(': '));
            }
            for (const name of names) {
                if (child.startsWith(name)) {
                    return child.substring(name.length + 1);
                }
            }
            if (child.startsWith(parent.code) || child.startsWith(parent.code.toUpperCase())) {
                return child.substring(parent.code.length + 1);
            }
            return child;
        }

        for (const set of sets) {
            if (set.parent_set_code) {
                continue;
            }
            const year = set.released_at.substring(0, 4);
            if (lasty == null || lasty !== year) {
                grid.appendChild(h('div', { class: 'year' }, [`– ${year} –`]));
            }
            const row = [];
            if (set.icon_svg_uri) {
                row.push(h('img', { src: set.icon_svg_uri }));
            }
            row.push(h('a', { href: newHash('set', set.code), class: set.set_type }, [set.name]));
            for (const child of children) {
                if (child.parent_set_code === set.code) {
                    row.push(h('a', { href: newHash('set', child.code), class: 'child' }, [shortname(set, child.name)]))
                }
            }
            grid.appendChild(h('div', { class: 'set' }, row));
            lasty = year;
        }
        output.appendChild(grid);
        output.appendChild(h('hr'));}

    function redraw() {
        if (!sets) {
            return;
        }
        const selectedSet = hash().get('set');
        if (selectedSet) {
            setInput.value = selectedSet;
            if (!(cards[0] && cards[0].set === selectedSet)) {
                const search = sets.find((s) => s.code === selectedSet).search_uri;
                loading();
                fetchAll(search).then((result) => {
                    cards = result;
                    redraw();
                });
            } else {
                drawCards();
            }
        } else {
            setInput.value = '';
            drawSets();
        }
    }
});
</script>
</html>
